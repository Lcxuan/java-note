## 泛型

把元素的类型设计成一个参数，这个类型参数叫做泛型

允许在定义类、接口时通过一个标识表示类中某个属性的类型或者某个方法返回值及参数类型

### 传统方法的问题分析

- 不能对加入到集合中的数据类型进行约束（不安全）

- 遍历时候，需要进行类型转换，如果集合中的数据量较大，对效率有影响，并且强转时可能出现异常

### 泛型好处

- 编译时，检查添加元素的类型，提高安全性

- 减少类型转换次数，提高效率

- 不提示编译警告

### 泛型介绍

- 泛型又称参数化类型，解决数据类型的安全性问题

- 在类声明或实例化时只要指定好性需要的具体的类型即可

- Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常，代码更简洁、健壮

- 作用：可以在类声明时通过一个标识表示类中某个属性的类型，或者某个方法的返回值的类型，或者参数类型

### 泛型语法和使用

泛型指向的数据类型只能是引用类型，不能是基本数据类型

在给泛型指定具体类型后，可以传入该类型或者其子类类型

使用形式

```java
第一种形式：
ArrayList<Integer> list = new ArrayList<Integer>();

第二种简写方式：【推荐】
ArrayList<Integer> list = new ArrayList<>();
```

泛型默认是Object

### 自定义泛型类

#### 基本语法

```java
class 类名<T,R...>{    ...代表可以有多个泛型
    成员
}.
注意细节
1、普通成员可以使用泛型(属性、方法)
2、使用泛型的数组，不能初始化
3、静态方法中不能使用类的泛型
4、泛型类的类型，是在创建对象时确定（因为创建对象时，需要指定确定类型）
5、如果在创建对象时，没有指定类型，默认为Object
6、异常类不能使用类的泛型
```

### 自定义泛型接口

#### 基本语法

```java
interface 接口名<T,R...>{

}
注意细节
1、接口中，静态成员也不能使用泛型
2、泛型接口的类型，在继承接口或者实现接口时确定
3、没有指定类型， 
```

### 自定义泛型方法

#### 基本语法

```java
修饰符<T,R...> 返回类型 方法名(参数列表){

}
注意细节：
1、泛型方法，可以定义在普通类中，也可以定义在泛型类中
2、当泛型方法被调用时，类型会确定
3、public void eat(E e){}，修饰符后没有<T,R>eat方法不是泛型方法，而是使用了泛型
4、泛型方法，可以使用类声明的泛型，也可以使用自己声明的泛型
```

例如：

```java
    public <E> List<E> copyFromArrayToList(E[] arr){
        List<E> list = new ArrayList<>();
        for (E e : arr) {
            list.add(e);
        }
        return list;
    }
```



### 泛型的继承和通配符

#### 泛型的继承

- 泛型不具备继承性
- ```java
  <?>：支持任意泛型类型
  ```
- ```java
  <? extends A>：支持A类以及A类的子类，规定了泛型的上限
  ```
- ```java
  <? super A>：支持A类以及A类的父类，不限于直接父类，规定了泛型的下限
  ```


